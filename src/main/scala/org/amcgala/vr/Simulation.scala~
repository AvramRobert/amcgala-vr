package org.amcgala.vr

import akka.actor.{ PoisonPill, ActorRef, ActorSystem, Props }

/**
  * Die absolute Position des Agenten auf dem Feld.
  * @param x die x-Koordinate der Position
  * @param y die y-Koordinate der Position
  */
case class Position(x: Int, y: Int)

case class Cell(cellType: CellTypes.CellType)

object SimulationAgent {

  case class Register(bot: ActorRef, position: Position)

  case class ChangeCellType(position: Position, cellType: CellTypes.CellType)

  case class ChangePosition(position: Position)

  case class PositionRequest(ref: ActorRef)
  
  case class CellRequest(ref: ActorRef)

  case class VicinityRequest(ref: ActorRef, distance: Int)

  def props(width: Int, height: Int) = Props(new SimulationAgent(width, height))
}

class SimulationAgent(val width: Int, val height: Int) extends Agent {

  import SimulationAgent._

  var field = (for {
    x ← 0 until width
    y ← 0 until height
  } yield Position(x, y) -> Cell(CellTypes.Floor)).toMap

  var positions = Map[ActorRef, Position]()

  def receive: Receive = {
    case Register(bot, position) ⇒
      if (field.exists(_._1 == position)) {
        bot ! Bot.Introduction
        bot ! Bot.PositionChange(position)
        positions = positions + (bot -> position)
      } else {
        bot ! PoisonPill
      }

    case ChangeCellType(position, cellType) ⇒
      if (field.exists(_._1 == position)) {
        field = field + (position -> Cell(cellType))
      }

    case ChangePosition(position) ⇒
      if (field.exists(_._1 == position)) {
        if (field(position).cellType != CellTypes.Forbidden) {
          positions = positions + (sender() -> position)
          sender() ! Bot.PositionChange(position)
        }
      }

    case PositionRequest(ref) ⇒
      for (pos ← positions.get(ref)) {
        sender() ! pos
      }

    case VicinityRequest(ref, dis) ⇒
      val pos = positions(ref)
      sender() ! positions.filter(t ⇒ Utils.distance(pos, t._2) < dis && t._1 != ref)
      
    case CellRequest(ref) =>
      val pos = positions(ref)
      sender() ! field(pos)
      
  }

}

class Simulation(val width: Int, val height: Int)(implicit system: ActorSystem) {

  import SimulationAgent._

  private val sim = system.actorOf(SimulationAgent.props(width, height))
  private val heartbeat = system.actorOf(HeartBeat.props())

  /**
    * Erzeugt einen neuen Bot und gibt die Referenz zurück.
    * @param cls die Klasse des Bots
    * @param position die Position des Bots
    * @tparam T der Typ des Bots. Muss eine Unterklasse von [[Bot]] sein
    * @return [[ActorRef]] des Bots
    */
  def spawnBot[T <: Bot](cls: Class[T], position: Position): ActorRef = {
    val bot = system.actorOf(Props(cls))
    sim ! Register(bot, position)
    bot
  }
  
  def spawnBot[T <: Bot](cls: Class[T]): ActorRef = {
    val bot = system.actorOf(Props(cls))
    sim ! Register(bot, randomPosition())
    bot    
  }

  def changeCellType(position: Position, cellType: CellTypes.CellType) = {
    sim ! ChangeCellType(position, cellType)
  }


  def randomPosition(): Position = {
    // TODO Muss Random position hinzufügen!
    Position(0,0)
  }
}

